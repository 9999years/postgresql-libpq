{-# LANGUAGE ForeignFunctionInterface, EmptyDataDecls, OverloadedStrings, ScopedTypeVariables #-}
module Database.PQ ( Connection
                   , ConnStatus(..)
                   , Result
                   , ResultStatus(..)

                   , connectdb
                   , setClientEncoding
                   , consumeInput
                   , errorMessage
                   , exec
                   , execPrepared
                   , getResult
                   , isBusy
                   , prepare
                   , reset
                   , sendPrepare
                   , sendQuery
                   , sendQueryPrepared
                   , status

                   , resultStatus
                   , ntuples
                   , nfields
                   , fname
                   , fnumber
                   , binaryTuples
                   )
where

#include <libpq-fe.h>

import Control.Monad ( when )
import Foreign
import Foreign.Ptr
import Foreign.C.Types
import Foreign.C.String
import GHC.Conc ( threadWaitRead, threadWaitWrite)
import System.Posix.Types ( Fd(..) )
import Data.List ( foldl' )

import qualified Data.ByteString.Char8 as Char8
import qualified Data.ByteString as B


-- | 'Connection' encapsulates a connection to the backend.
newtype Connection = Conn (ForeignPtr PGconn) deriving (Eq, Show)
data PGconn

-- | 'Result' encapsulates the result of a query (or more precisely,
-- of a single SQL command --- a query string given to 'sendQuery' can
-- contain multiple commands and thus return multiple instances of
-- 'Result'.
newtype Result = Result (ForeignPtr PGresult) deriving (Eq, Show)
data PGresult


-- | Obtains the file descriptor number of the connection socket to
-- the server.
connFd :: Connection
       -> IO (Maybe Fd)
connFd (Conn conn) =
    do cFd <- withForeignPtr conn c_PQsocket
       return $ case cFd of
                  -1 -> Nothing
                  _ -> Just $ Fd cFd

-- | Returns the error message most recently generated by an operation
-- on the connection.
errorMessage :: Connection
             -> IO B.ByteString
errorMessage (Conn conn) =
    do cs <- withForeignPtr conn (return . c_PQerrorMessage)
       B.packCString cs


-- | Helper function that calls fail with the result of errorMessage
failErrorMessage :: Connection
                 -> IO a
failErrorMessage conn =
    do msg <- errorMessage conn
       fail $ Char8.unpack msg

data ConnStatus
    = ConnectionOk                 -- ^ The 'Connection' is ready.
    | ConnectionBad                -- ^ The connection procedure has failed.
    | ConnectionStarted            -- ^ Waiting for connection to be made.
    | ConnectionMade               -- ^ Connection OK; waiting to send.
    | ConnectionAwaitingResponse   -- ^ Waiting for a response from the server.
    | ConnectionAuthOk             -- ^ Received authentication;
                                   -- waiting for backend start-up to
                                   -- finish.
    | ConnectionSetEnv             -- ^ Negotiating environment-driven
                                   -- parameter settings.
    | ConnectionSSLStartup         -- ^ Negotiating SSL encryption.
    | ConnectionOther Int          -- ^ Unknown connection state
      deriving Show


-- | Returns the status of the connection.
status :: Connection
       -> IO ConnStatus
status (Conn conn) =
    withForeignPtr conn (return . status')
    where
      status' connPtr =
          case c_PQstatus connPtr of
            (#const CONNECTION_OK)               -> ConnectionOk
            (#const CONNECTION_BAD)              -> ConnectionBad
            (#const CONNECTION_STARTED)          -> ConnectionStarted
            (#const CONNECTION_MADE)             -> ConnectionMade
            (#const CONNECTION_AWAITING_RESPONSE)-> ConnectionAwaitingResponse
            (#const CONNECTION_AUTH_OK)          -> ConnectionAuthOk
            (#const CONNECTION_SETENV)           -> ConnectionSetEnv
            (#const CONNECTION_SSL_STARTUP)      -> ConnectionSSLStartup
            --(#const CONNECTION_NEEDED)           -> ConnectionNeeded
            c                                    -> ConnectionOther $ fromEnum c

-- | Makes a new connection to the database server.
connectdb :: String -- ^ Connection info
          -> IO Connection
connectdb connStr =
    do conn <- connectStart connStr
       poll conn
       return conn
    where
      poll conn =
          do stat <- connectPoll conn
             case stat of
               PollingReading -> connWaitRead conn poll
               PollingOk      -> return ()
               PollingFailed  -> failErrorMessage conn
               PollingWriting -> connWaitWrite conn poll


-- | Resets the communication channel to the server.
reset :: Connection
      -> IO ()
reset connection =
    do resetStart connection
       poll connection
    where
      poll conn =
          do stat <- resetPoll conn
             case stat of
               PollingReading -> connWaitRead conn poll
               PollingOk      -> return ()
               PollingFailed  -> failErrorMessage conn
               PollingWriting -> connWaitWrite conn poll


-- | Sets the client encoding.
setClientEncoding :: Connection -> B.ByteString -> IO ()
setClientEncoding (Conn conn) enc =
    do stat <- withForeignPtr conn $ \c -> do
                 B.useAsCString enc $ \s -> do
                   c_PQsetClientEncoding c s

       case stat of
         0 -> return ()
         _ -> failErrorMessage (Conn conn)


-- | Submits a command to the server and waits for the result.
exec :: Connection
     -> B.ByteString
     -> IO Result
exec connection query =
    do sendQuery connection query
       flush connection
       Just result <- connWaitRead connection getResult
       throwAwaySubsequentResults connection
       return result

-- | Submits a request to create a prepared statement with the given
-- parameters, and waits for completion.
prepare :: Connection
        -> B.ByteString
        -> B.ByteString
        -> Maybe [Oid]
        -> IO Result
prepare connection stmtName query mParamTypes =
    do sendPrepare connection stmtName query mParamTypes
       flush connection
       Just result <- connWaitRead connection getResult
       throwAwaySubsequentResults connection
       return result


execPrepared :: Connection
             -> B.ByteString
             -> [Maybe (B.ByteString, Bool)]
             -> Bool
             -> IO Result
execPrepared connection stmtName mPairs binary_result =
    do sendQueryPrepared connection stmtName mPairs binary_result
       flush connection
       Just result <- connWaitRead connection getResult
       throwAwaySubsequentResults connection
       return result


-- | Sends a request to execute a prepared statement with given
-- parameters, without waiting for the result(s).
sendQueryPrepared :: Connection
                  -> B.ByteString
                  -> [Maybe (B.ByteString, Bool)]
                  -> Bool
                  -> IO ()
sendQueryPrepared (Conn conn) stmtName mPairs rFmt =
    do let (values, lengths, formats) = foldl' accum ([],[],[]) $ reverse mPairs
           c_lengths = map toEnum lengths :: [CInt]
           n = toEnum $ length mPairs
       stat <- withForeignPtr conn $ \c -> do
                 B.useAsCString stmtName $ \s -> do
                   withMany (maybeWith B.useAsCString) values $ \c_values ->
                     withArray c_values $ \vs -> do
                       withArray c_lengths $ \ls -> do
                         withArray formats $ \fs -> do
                           c_PQsendQueryPrepared c s n vs ls fs (fromBool rFmt)


       case stat of
         1 -> return ()
         _ -> failErrorMessage (Conn conn)

    where
      accum (a,b,c) Nothing = (Nothing:a, 0:b, 0:c)
      accum (a,b,c) (Just (v, f)) = ((Just v):a, (B.length v):b, (fromBool f):c)


-- | Sends a request to create a prepared statement with the given
-- parameters, without waiting for completion.
sendPrepare :: Connection
            -> B.ByteString
            -> B.ByteString
            -> Maybe [Oid]
            -> IO ()
sendPrepare connection@(Conn conn) stmtName query mParamTypes =
    do stat <- withForeignPtr conn $ \c -> do
                 B.useAsCString stmtName $ \s -> do
                   B.useAsCString query $ \q -> do
                     maybeWith withArray mParamTypes $ \o -> do
                       let l = maybe 0 (toEnum . length) mParamTypes
                       c_PQsendPrepare c s q l o
       case stat of
         1 -> return ()
         _ -> failErrorMessage connection


-- | Helper function to consume and ignore all results available
-- results
throwAwaySubsequentResults :: Connection
                           -> IO ()
throwAwaySubsequentResults connection =
    do readData connection
       result <- getResult connection
       case result of
         Nothing -> return ()
         Just _ -> throwAwaySubsequentResults connection
    where
      readData conn =
          do consumeInput conn
             busy <- isBusy conn
             if busy
                 then connWaitRead conn readData
                 else return ()


-- | Helper function for using 'threadWaitRead' with a 'Connection'
connWaitRead :: Connection
             -> (Connection -> IO a)
             -> IO a
connWaitRead conn ioa =
    do fd <- connFd conn
       maybe (return ()) threadWaitRead fd
       ioa conn


-- | Helper function for using 'threadWaitWrite' with a 'Connection'
connWaitWrite :: Connection
              -> (Connection -> IO a)
              -> IO a
connWaitWrite conn ioa =
    do fd <- connFd conn
       maybe (return ()) threadWaitWrite fd
       ioa conn


connectStart :: String
             -> IO Connection
connectStart connStr =
    do connPtr <- withCString connStr c_PQconnectStart
       if connPtr == nullPtr
           then fail $ "PQconnectStart failed to allocate memory"
           else Conn `fmap` newForeignPtr c_PQfinish connPtr


data PollingStatus
    = PollingFailed
    | PollingReading
    | PollingWriting
    | PollingOk deriving Show


connectPoll :: Connection
            -> IO PollingStatus
connectPoll (Conn conn) =
    withForeignPtr conn $ \connPtr -> do
      code <- c_PQconnectPoll connPtr
      case code of
        (#const PGRES_POLLING_READING) -> return PollingReading
        (#const PGRES_POLLING_OK)      -> return PollingOk
        (#const PGRES_POLLING_FAILED)  -> return PollingFailed
        (#const PGRES_POLLING_WRITING) -> return PollingWriting
        _ -> fail $ "PQconnectPoll returned " ++ show code


resetStart :: Connection
           -> IO ()
resetStart (Conn conn) =
    withForeignPtr conn $ \connPtr -> do
      result <- c_PQresetStart connPtr
      case result of
        1 -> return ()
        _ -> fail $ "PQresetStart returned " ++ show result


resetPoll :: Connection
          -> IO PollingStatus
resetPoll (Conn conn) =
    withForeignPtr conn $ \connPtr -> do
      code <- c_PQresetPoll connPtr
      case code of
        (#const PGRES_POLLING_READING) -> return PollingReading
        (#const PGRES_POLLING_OK)      -> return PollingOk
        (#const PGRES_POLLING_FAILED)  -> return PollingFailed
        (#const PGRES_POLLING_WRITING) -> return PollingWriting
        _ -> fail $ "PQresetPoll returned " ++ show code


sendQuery :: Connection
          -> B.ByteString
          -> IO ()
sendQuery connection@(Conn conn) query =
    do stat <- withForeignPtr conn $ \p -> do
                 B.useAsCString query (c_PQsendQuery p)
       case stat of
         1 -> return ()
         _ -> failErrorMessage connection


flush :: Connection
      -> IO ()
flush connection@(Conn conn) =
    do stat <- withForeignPtr conn c_PQflush
       case stat of
         0 -> return ()
         1 -> connWaitWrite (Conn conn) flush
         _ -> failErrorMessage connection


-- | If input is available from the server, consume it.
consumeInput :: Connection
             -> IO ()
consumeInput connection@(Conn conn) =
    do stat <- withForeignPtr conn c_PQconsumeInput
       case stat of
         1 -> return ()
         _ -> failErrorMessage connection


-- | Returns True if a command is busy, that is, getResult would block
-- waiting for input. A False return indicates that getResult can be
-- called with assurance of not blocking.
isBusy :: Connection
       -> IO Bool
isBusy (Conn conn) =
    do stat <- withForeignPtr conn c_PQisBusy
       case stat of
         1 -> return True
         0 -> return False
         _ -> fail $ "PQisBusy returned unexpected result " ++ show stat


-- | Waits for the next result from a prior sendQuery, sendQueryParams,
-- sendPrepare, or sendQueryPrepared call, and returns it. A null
-- pointer is returned when the command is complete and there will be
-- no more results.
getResult :: Connection
          -> IO (Maybe Result)
getResult (Conn conn) =
    do resPtr <- withForeignPtr conn c_PQgetResult
       if resPtr == nullPtr
           then return Nothing
           else (Just . Result) `fmap` newForeignPtr c_PQclear resPtr


data ResultStatus = EmptyQuery
                  | CommandOk
                  | TuplesOk
                  | CopyOut
                  | CopyIn
                  | BadResponse
                  | NonfatalError
                  | FatalError deriving Show


-- | Returns the result status of the command.
resultStatus :: Result
             -> IO ResultStatus
resultStatus (Result res) =
      withForeignPtr res $ \resPtr -> do
          case c_PQresultStatus resPtr of
            (#const PGRES_EMPTY_QUERY)    -> return EmptyQuery
            (#const PGRES_COMMAND_OK)     -> return CommandOk
            (#const PGRES_TUPLES_OK)      -> return TuplesOk
            (#const PGRES_COPY_OUT)       -> return CopyOut
            (#const PGRES_COPY_IN)        -> return CopyIn
            (#const PGRES_BAD_RESPONSE)   -> return BadResponse
            (#const PGRES_NONFATAL_ERROR) -> return NonfatalError
            (#const PGRES_FATAL_ERROR)    -> return FatalError
            s -> fail $ "Unexpected result from PQresultStatus" ++ show s


-- | Returns the number of rows (tuples) in the query result. Because
-- it returns an integer result, large result sets might overflow the
-- return value on 32-bit operating systems.
ntuples :: Result
        -> IO Int
ntuples (Result res) = withForeignPtr res (return . fromEnum . c_PQntuples)


-- | Returns the number of columns (fields) in each row of the query
-- result.
nfields :: Result
        -> IO Int
nfields (Result res) = withForeignPtr res (return . fromEnum . c_PQnfields)


-- | Returns the column name associated with the given column
-- number. Column numbers start at 0.
fname :: Result
      -> Int
      -> IO B.ByteString
fname result@(Result res) colNum =
      do nf <- nfields result
         when (colNum < 0 || colNum >= nf) (failure nf)
         cs <- withForeignPtr res $ (flip c_PQfname) $ toEnum colNum
         if cs == nullPtr
           then failure nf
           else B.packCString cs
    where
      failure nf = fail ("column number " ++
                         show colNum ++
                         " is out of range 0.." ++
                         show (nf - 1))


-- | Returns the column number associated with the given column name.
fnumber :: Result
        -> B.ByteString
        -> IO (Maybe Int)
fnumber (Result res) columnName =
    do num <- withForeignPtr res $ \resPtr -> do
                B.useAsCString columnName $ \cColumnName -> do
                  c_PQfnumber resPtr cColumnName
       return $ if num == -1
                  then Nothing
                  else Just $ fromIntegral num


-- | Returns True if the Result contains binary data and False if it
-- contains text data.
binaryTuples :: Result
             -> IO Bool
binaryTuples (Result res) = toBool `fmap` withForeignPtr res c_PQbinaryTuples


type Oid = CUInt

foreign import ccall unsafe "libpq-fe.h PQstatus"
    c_PQstatus :: Ptr PGconn -> CInt

foreign import ccall unsafe "libpq-fe.h PQsocket"
    c_PQsocket :: Ptr PGconn -> IO CInt

foreign import ccall unsafe "libpq-fe.h PQerrorMessage"
    c_PQerrorMessage :: Ptr PGconn -> CString

foreign import ccall unsafe "libpq-fe.h PQconnectStart"
    c_PQconnectStart :: CString ->IO (Ptr PGconn)

foreign import ccall unsafe "libpq-fe.h PQconnectPoll"
    c_PQconnectPoll :: Ptr PGconn ->IO CInt

foreign import ccall unsafe "libpq-fe.h PQresetStart"
    c_PQresetStart :: Ptr PGconn ->IO CInt

foreign import ccall unsafe "libpq-fe.h PQresetPoll"
    c_PQresetPoll :: Ptr PGconn ->IO CInt

foreign import ccall unsafe "libpq-fe.h &PQfinish"
    c_PQfinish :: FunPtr (Ptr PGconn -> IO ())

foreign import ccall unsafe "libpq-fe.h PQsetClientEncoding"
    c_PQsetClientEncoding :: Ptr PGconn -> CString -> IO CInt

foreign import ccall unsafe "libpq-fe.h PQsendQuery"
    c_PQsendQuery :: Ptr PGconn -> CString ->IO CInt

foreign import ccall unsafe "libpq-fe.h PQflush"
    c_PQflush :: Ptr PGconn ->IO CInt

foreign import ccall unsafe "libpq-fe.h PQconsumeInput"
    c_PQconsumeInput :: Ptr PGconn ->IO CInt

foreign import ccall unsafe "libpq-fe.h PQisBusy"
    c_PQisBusy :: Ptr PGconn -> IO CInt

foreign import ccall unsafe "libpq-fe.h PQgetResult"
    c_PQgetResult :: Ptr PGconn ->IO (Ptr PGresult)

foreign import ccall unsafe "libpq-fe.h &PQclear"
    c_PQclear :: FunPtr (Ptr PGresult ->IO ())

foreign import ccall unsafe "libpq-fe.h PQresultStatus"
    c_PQresultStatus :: Ptr PGresult -> CInt

foreign import ccall unsafe "libpq-fe.h PQntuples"
    c_PQntuples :: Ptr PGresult -> CInt

foreign import ccall unsafe "libpq-fe.h PQnfields"
    c_PQnfields :: Ptr PGresult -> CInt

foreign import ccall unsafe "libpq-fe.h PQfname"
    c_PQfname :: Ptr PGresult -> CInt -> IO CString

foreign import ccall unsafe "libpq-fe.h PQfnumber"
    c_PQfnumber :: Ptr PGresult -> CString -> IO CInt

foreign import ccall unsafe "libpq-fe.h PQbinaryTuples"
    c_PQbinaryTuples :: Ptr PGresult -> IO CInt

foreign import ccall unsafe "libpq-fe.h PQsendPrepare"
    c_PQsendPrepare :: Ptr PGconn -> CString -> CString -> CInt -> Ptr Oid
                    -> IO CInt

foreign import ccall unsafe "libpq-fe.h PQsendQueryPrepared"
    c_PQsendQueryPrepared :: Ptr PGconn -> CString -> CInt -> Ptr CString
                          -> Ptr CInt -> Ptr CInt -> CInt -> IO CInt
